package malwaremanager

import (
	"node-agent/pkg/config"
	"node-agent/pkg/malwaremanager"
	utils "node-agent/pkg/malwaremanager/utils"
	"node-agent/pkg/rulemanager/exporters"
	nautils "node-agent/pkg/utils"
	"os"
	"time"

	mapset "github.com/deckarep/golang-set/v2"
	"github.com/goradd/maps"
	containercollection "github.com/inspektor-gadget/inspektor-gadget/pkg/container-collection"
	tracerexectype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/exec/types"
	traceropentype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/open/types"
)

const ScannedFilesMaxBufferLength = 10000

type MalwareManager struct {
	cfg              config.Config
	malwareScanners  []MalwareScanner
	exporter         exporters.Exporter
	scannedFiles     maps.SafeMap[string, mapset.Set[string]]
	containerIdToPid maps.SafeMap[string, uint32]
}

var _ malwaremanager.MalwareManagerClient = (*MalwareManager)(nil)

func CreateMalwareManager(malwareScanners []MalwareScanner, exporter exporters.Exporter, cfg config.Config) (*MalwareManager, error) {
	return &MalwareManager{
		cfg:             cfg,
		malwareScanners: malwareScanners,
		exporter:        exporter,
	}, nil
}

func (mm *MalwareManager) ContainerCallback(notif containercollection.PubSubEvent) {
	t := time.NewTicker(mm.cfg.InitialDelay)

	switch notif.Type {
	case containercollection.EventTypeAddContainer:
		mm.containerIdToPid.Set(notif.Container.Runtime.ContainerID, notif.Container.Pid)
	case containercollection.EventTypeRemoveContainer:
		mm.containerIdToPid.Delete(notif.Container.Runtime.ContainerID)
		t.Stop()
		mm.scannedFiles.Delete(notif.Container.Runtime.ContainerID)
	}

	go func() {
		for range t.C {
			mm.scannedFiles.Set(notif.Container.Runtime.ContainerID, mapset.NewSet[string]())
		}
	}()
}

func (mm *MalwareManager) ReportFileExec(_ string, event tracerexectype.Event) {
	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(nautils.ExecveEventType, &event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			mm.exporter.SendMalwareAlert(result)
		}
	}

	if mm.scannedFiles.Has(event.Runtime.ContainerID) && mm.scannedFiles.Get(event.Runtime.ContainerID).Cardinality() <= ScannedFilesMaxBufferLength {
		hostFilePath, err := utils.GetHostFilePathFromEvent(&event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
		if err != nil {
			return
		}

		mm.scannedFiles.Get(event.Runtime.ContainerID).Add(hostFilePath)
	}
}

func (mm *MalwareManager) ReportFileOpen(_ string, event traceropentype.Event) {
	// Skip if file is not opened for reading.
	if event.FlagsRaw&int32(os.O_RDONLY) == 0 {
		return
	}

	hostFilePath, err := utils.GetHostFilePathFromEvent(&event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
	if err != nil {
		return
	}

	if mm.scannedFiles.Has(event.Runtime.ContainerID) {
		// If the file has already been scanned, return.
		scannedFiles := mm.scannedFiles.Get(event.Runtime.ContainerID)
		if scannedFiles.Contains(hostFilePath) {
			return
		}

		// Add the scanned file to the cache.
		if scannedFiles.Cardinality() <= ScannedFilesMaxBufferLength {
			scannedFiles.Add(hostFilePath)
		}
	}

	// Skip directories.
	if utils.IsDirectory(hostFilePath) {
		return
	}

	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(nautils.OpenEventType, &event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			mm.exporter.SendMalwareAlert(result)
		}
	}
}
