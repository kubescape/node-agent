package malwaremanager

import (
	"node-agent/pkg/malwaremanager"
	utils "node-agent/pkg/malwaremanager/utils"
	"node-agent/pkg/rulemanager/exporters"
	nautils "node-agent/pkg/utils"

	mapset "github.com/deckarep/golang-set/v2"
	"github.com/goradd/maps"
	containercollection "github.com/inspektor-gadget/inspektor-gadget/pkg/container-collection"
	tracerexectype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/exec/types"
	traceropentype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/open/types"
)

const (
	MaxScannedFilesQueueSize = 1000
)

type MalwareManager struct {
	malwareScanners  []MalwareScanner
	exporter         exporters.Exporter
	scannedFiles     mapset.Set[string]
	containerIdToPid maps.SafeMap[string, uint32]
}

var _ malwaremanager.MalwareManagerClient = (*MalwareManager)(nil)

func CreateMalwareManager(malwareScanners []MalwareScanner, exporter exporters.Exporter) (*MalwareManager, error) {
	return &MalwareManager{
		malwareScanners: malwareScanners,
		exporter:        exporter,
		scannedFiles:    mapset.NewSet[string](),
	}, nil
}

func (mm *MalwareManager) ContainerCallback(notif containercollection.PubSubEvent) {
	switch notif.Type {
	case containercollection.EventTypeAddContainer:
		mm.containerIdToPid.Set(notif.Container.Runtime.ContainerID, notif.Container.Pid)
	case containercollection.EventTypeRemoveContainer:
		mm.containerIdToPid.Delete(notif.Container.Runtime.ContainerID)
	}
}

func (mm *MalwareManager) ReportFileExec(_ string, event tracerexectype.Event) {
	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(nautils.ExecveEventType, &event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			mm.exporter.SendMalwareAlert(result)
		}
	}

	if mm.scannedFiles.Cardinality() <= MaxScannedFilesQueueSize {
		hostFilePath, err := utils.GetHostFilePathFromEvent(&event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
		if err != nil {
			return
		}

		mm.scannedFiles.Add(hostFilePath)
	}
}

func (mm *MalwareManager) ReportFileOpen(_ string, event traceropentype.Event) {
	if mm.scannedFiles.Contains(event.FullPath) {
		return
	}

	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(nautils.OpenEventType, &event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			mm.exporter.SendMalwareAlert(result)
		}
	}

	if mm.scannedFiles.Cardinality() <= MaxScannedFilesQueueSize {
		hostFilePath, err := utils.GetHostFilePathFromEvent(&event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
		if err != nil {
			return
		}

		mm.scannedFiles.Add(hostFilePath)
	}
}
