package malwaremanager

import (
	"fmt"
	"node-agent/pkg/config"
	"node-agent/pkg/exporters"
	"node-agent/pkg/k8sclient"
	"node-agent/pkg/malwaremanager"
	nautils "node-agent/pkg/utils"
	utils "node-agent/pkg/utils"
	"time"

	"github.com/armosec/utils-k8s-go/wlid"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/goradd/maps"
	containercollection "github.com/inspektor-gadget/inspektor-gadget/pkg/container-collection"
	tracerexectype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/exec/types"
	traceropentype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/open/types"
	"github.com/kubescape/go-logger"
	"github.com/kubescape/go-logger/helpers"
	"github.com/kubescape/k8s-interface/workloadinterface"
)

const ScannedFilesMaxBufferLength = 10000

type MalwareManager struct {
	cfg              config.Config
	malwareScanners  []MalwareScanner
	exporter         exporters.Exporter
	scannedFiles     maps.SafeMap[string, mapset.Set[string]]
	containerIdToPid maps.SafeMap[string, uint32]
	k8sClient        k8sclient.K8sClientInterface
	podToWlid        maps.SafeMap[string, string]
	nodeName         string
	clusterName      string
}

var _ malwaremanager.MalwareManagerClient = (*MalwareManager)(nil)

func CreateMalwareManager(malwareScanners []MalwareScanner, exporter exporters.Exporter, cfg config.Config, k8sClient k8sclient.K8sClientInterface, nodeName string, clusterName string) (*MalwareManager, error) {
	return &MalwareManager{
		cfg:             cfg,
		malwareScanners: malwareScanners,
		exporter:        exporter,
		k8sClient:       k8sClient,
		nodeName:        nodeName,
		clusterName:     clusterName,
	}, nil
}

func (mm *MalwareManager) ContainerCallback(notif containercollection.PubSubEvent) {
	t := time.NewTicker(mm.cfg.InitialDelay)

	switch notif.Type {
	case containercollection.EventTypeAddContainer:
		mm.containerIdToPid.Set(notif.Container.Runtime.ContainerID, notif.Container.Pid)
		if !mm.podToWlid.Has(notif.Container.K8s.PodName) {
			wlid, err := mm.getWorkloadIdentifier(notif.Container.K8s.Namespace, notif.Container.K8s.PodName)
			if err != nil {
				logger.L().Debug("MalwareManager - failed to get workload identifier", helpers.Error(err), helpers.String("k8s workload", notif.Container.K8s.PodName))
			} else {
				mm.podToWlid.Set(notif.Container.K8s.PodName, wlid)
			}
		}
	case containercollection.EventTypeRemoveContainer:
		mm.containerIdToPid.Delete(notif.Container.Runtime.ContainerID)
		t.Stop()
		mm.scannedFiles.Delete(notif.Container.Runtime.ContainerID)
		mm.podToWlid.Delete(notif.Container.K8s.PodName)
	}

	go func() {
		for {
			select {
			case <-t.C:
				mm.scannedFiles.Set(notif.Container.Runtime.ContainerID, mapset.NewSet[string]())
				return
			}
		}
	}()
}

func (mm *MalwareManager) getWorkloadIdentifier(podNamespace, podName string) (string, error) {
	wl, err := mm.k8sClient.GetWorkload(podNamespace, "Pod", podName)
	if err != nil {
		return "", fmt.Errorf("failed to get workload: %w", err)
	}
	pod := wl.(*workloadinterface.Workload)

	// find parentWlid
	kind, name, err := mm.k8sClient.CalculateWorkloadParentRecursive(pod)
	if err != nil {
		return "", fmt.Errorf("failed to calculate workload parent: %w", err)
	}
	parentWorkload, err := mm.k8sClient.GetWorkload(pod.GetNamespace(), kind, name)
	if err != nil {
		return "", fmt.Errorf("failed to get parent workload: %w", err)
	}
	w := parentWorkload.(*workloadinterface.Workload)
	generatedWlid := w.GenerateWlid(mm.clusterName)
	err = wlid.IsWlidValid(generatedWlid)
	if err != nil {
		return "", fmt.Errorf("failed to validate WLID: %w", err)
	}

	return generatedWlid, nil
}

func (mm *MalwareManager) ReportFileExec(_ string, event tracerexectype.Event) {
	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(nautils.ExecveEventType, &event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			result.SetWorkloadDetails(mm.podToWlid.Get(event.GetPod()))
			mm.exporter.SendMalwareAlert(result)
		}
	}

	if mm.scannedFiles.Has(event.Runtime.ContainerID) && mm.scannedFiles.Get(event.Runtime.ContainerID).Cardinality() <= ScannedFilesMaxBufferLength {
		hostFilePath, err := nautils.GetHostFilePathFromEvent(&event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
		if err != nil {
			return
		}

		mm.scannedFiles.Get(event.Runtime.ContainerID).Add(hostFilePath)
	}
}

func (mm *MalwareManager) ReportFileOpen(_ string, event traceropentype.Event) {
	// TODO: Add a check if the file is being opened for read.

	// Skip directories.
	if event.ModeRaw.IsDir() {
		return
	}

	hostFilePath, err := utils.GetHostFilePathFromEvent(&event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
	if err != nil {
		return
	}

	if mm.scannedFiles.Has(event.Runtime.ContainerID) {
		// If the file has already been scanned, return.
		scannedFiles := mm.scannedFiles.Get(event.Runtime.ContainerID)
		if scannedFiles.Contains(hostFilePath) {
			return
		}

		// Add the scanned file to the cache.
		if scannedFiles.Cardinality() <= ScannedFilesMaxBufferLength {
			scannedFiles.Add(hostFilePath)
		}
	}

	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(nautils.OpenEventType, &event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			result.SetWorkloadDetails(mm.podToWlid.Get(event.GetPod()))
			mm.exporter.SendMalwareAlert(result)
		}
	}
}
