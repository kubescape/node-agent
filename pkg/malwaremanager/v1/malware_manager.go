package malwaremanager

import (
	"fmt"
	"node-agent/pkg/config"
	"node-agent/pkg/exporters"
	"node-agent/pkg/k8sclient"
	"node-agent/pkg/malwaremanager"
	clamavv1 "node-agent/pkg/malwaremanager/v1/clamav"
	"node-agent/pkg/metricsmanager"
	"node-agent/pkg/utils"
	"os"
	"path/filepath"
	"time"

	"github.com/armosec/utils-k8s-go/wlid"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/dustin/go-humanize"
	"github.com/goradd/maps"
	containercollection "github.com/inspektor-gadget/inspektor-gadget/pkg/container-collection"
	tracerexectype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/exec/types"
	traceropentype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/open/types"
	"github.com/kubescape/go-logger"
	"github.com/kubescape/go-logger/helpers"
	"github.com/kubescape/k8s-interface/workloadinterface"
)

const ScannedFilesMaxBufferLength = 10000

type MalwareManager struct {
	scannedFiles         maps.SafeMap[string, mapset.Set[string]]
	containerIdToPid     maps.SafeMap[string, uint32]
	podToWlid            maps.SafeMap[string, string]
	exporter             exporters.Exporter
	metrics              metricsmanager.MetricsManager
	k8sClient            k8sclient.K8sClientInterface
	nodeName             string
	clusterName          string
	malwareScanners      []malwaremanager.MalwareScanner
	cfg                  config.Config
	containerIdToShimPid maps.SafeMap[string, uint32]
}

var _ malwaremanager.MalwareManagerClient = (*MalwareManager)(nil)

func CreateMalwareManager(cfg config.Config, k8sClient k8sclient.K8sClientInterface, nodeName string, clusterName string, exporter exporters.Exporter, prometheusExporter metricsmanager.MetricsManager) (*MalwareManager, error) {

	// Create malware scanners
	malwareScanners := []malwaremanager.MalwareScanner{}

	// Create ClamAV scanner
	// Check if ClamAV is enabled (CLAMAV_ADDRESS env var is set in the format <host>:<port>)
	if clamavAddress, present := os.LookupEnv("CLAMAV_ADDRESS"); present {
		clamavConfig := clamavv1.ClamAVConfig{
			Address: clamavAddress,
		}
		clamavScanner, err := clamavv1.CreateClamAVClient(&clamavConfig)
		if err != nil {
			return nil, err
		}
		malwareScanners = append(malwareScanners, clamavScanner)
	}
	return &MalwareManager{
		cfg:             cfg,
		malwareScanners: malwareScanners,
		exporter:        exporter,
		k8sClient:       k8sClient,
		nodeName:        nodeName,
		clusterName:     clusterName,
		metrics:         prometheusExporter,
	}, nil
}

func (mm *MalwareManager) ContainerCallback(notif containercollection.PubSubEvent) {
	t := time.NewTicker(mm.cfg.InitialDelay)

	switch notif.Type {
	case containercollection.EventTypeAddContainer:
		mm.containerIdToPid.Set(notif.Container.Runtime.ContainerID, notif.Container.Pid)
		if !mm.podToWlid.Has(notif.Container.K8s.PodName) {
			wlid, err := mm.getWorkloadIdentifier(notif.Container.K8s.Namespace, notif.Container.K8s.PodName)
			if err != nil {
				logger.L().Debug("MalwareManager - failed to get workload identifier", helpers.Error(err), helpers.String("k8s workload", notif.Container.K8s.PodName))
			} else {
				mm.podToWlid.Set(notif.Container.K8s.PodName, wlid)
			}
		}
		shim, err := utils.GetProcessStat(int(notif.Container.Pid))
		if err != nil {
			logger.L().Warning("RuleManager - failed to get shim process", helpers.Error(err))
		} else {
			mm.containerIdToShimPid.Set(notif.Container.Runtime.ContainerID, uint32(shim.PPID))
		}
	case containercollection.EventTypeRemoveContainer:
		mm.containerIdToPid.Delete(notif.Container.Runtime.ContainerID)
		t.Stop()
		mm.scannedFiles.Delete(notif.Container.Runtime.ContainerID)
		mm.podToWlid.Delete(notif.Container.K8s.PodName)
		mm.containerIdToShimPid.Delete(notif.Container.Runtime.ContainerID)
	}

	go func() {
		for {
			select {
			case <-t.C:
				mm.scannedFiles.Set(notif.Container.Runtime.ContainerID, mapset.NewSet[string]())
				return
			}
		}
	}()
}

func (mm *MalwareManager) getWorkloadIdentifier(podNamespace, podName string) (string, error) {
	wl, err := mm.k8sClient.GetWorkload(podNamespace, "Pod", podName)
	if err != nil {
		return "", fmt.Errorf("failed to get workload: %w", err)
	}
	pod := wl.(*workloadinterface.Workload)

	// find parentWlid
	kind, name, err := mm.k8sClient.CalculateWorkloadParentRecursive(pod)
	if err != nil {
		return "", fmt.Errorf("failed to calculate workload parent: %w", err)
	}
	parentWorkload, err := mm.k8sClient.GetWorkload(pod.GetNamespace(), kind, name)
	if err != nil {
		return "", fmt.Errorf("failed to get parent workload: %w", err)
	}
	w := parentWorkload.(*workloadinterface.Workload)
	generatedWlid := w.GenerateWlid(mm.clusterName)
	err = wlid.IsWlidValid(generatedWlid)
	if err != nil {
		return "", fmt.Errorf("failed to validate WLID: %w", err)
	}

	return generatedWlid, nil
}

func (mm *MalwareManager) ReportFileExec(_ string, event tracerexectype.Event) {
	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(utils.ExecveEventType, &event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			result.SetWorkloadDetails(mm.podToWlid.Get(event.GetPod()))
			mm.exporter.SendMalwareAlert(result)
		}
	}

	if mm.scannedFiles.Has(event.Runtime.ContainerID) && mm.scannedFiles.Get(event.Runtime.ContainerID).Cardinality() <= ScannedFilesMaxBufferLength {
		hostFilePath, err := utils.GetHostFilePathFromEvent(&event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
		if err != nil {
			return
		}

		mm.scannedFiles.Get(event.Runtime.ContainerID).Add(hostFilePath)
	}
}

func (mm *MalwareManager) ReportFileOpen(_ string, event traceropentype.Event) {
	// TODO: Add a check if the file is being opened for read.

	// Skip directories.
	if event.ModeRaw.IsDir() {
		return
	}

	hostFilePath, err := utils.GetHostFilePathFromEvent(&event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
	if err != nil {
		return
	}

	if mm.scannedFiles.Has(event.Runtime.ContainerID) {
		// If the file has already been scanned, return.
		scannedFiles := mm.scannedFiles.Get(event.Runtime.ContainerID)
		if scannedFiles.Contains(hostFilePath) {
			return
		}

		// Add the scanned file to the cache.
		if scannedFiles.Cardinality() <= ScannedFilesMaxBufferLength {
			scannedFiles.Add(hostFilePath)
		}
	}

	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(utils.OpenEventType, &event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			result.SetWorkloadDetails(mm.podToWlid.Get(event.GetPod()))
			result = mm.enrichMalwareResult(result)
			mm.exporter.SendMalwareAlert(result)
			mm.metrics.ReportRuleAlert(result.GetBasicRuntimeAlert().AlertName)
		}
	}
}

func (mm *MalwareManager) enrichMalwareResult(malwareResult malwaremanager.MalwareResult) malwaremanager.MalwareResult {
	path, err := utils.GetPathFromPid(malwareResult.GetRuntimeProcessDetails().ProcessTree.PID)
	hostPath := ""
	if err != nil {
		path = ""
	} else {
		hostPath = filepath.Join("/proc", fmt.Sprintf("/%d/root/%s", malwareResult.GetRuntimeProcessDetails().ProcessTree.PID, path))
	}

	// Enrich BaseRuntimeAlert
	baseRuntimeAlert := malwareResult.GetBasicRuntimeAlert()

	baseRuntimeAlert.Timestamp = time.Unix(int64(malwareResult.GetTriggerEvent().Timestamp)/1e9, 0)

	if baseRuntimeAlert.MD5Hash == "" && hostPath != "" {
		md5hash, err := utils.CalculateMD5FileHash(hostPath)
		if err != nil {
			md5hash = ""
		}
		baseRuntimeAlert.MD5Hash = md5hash
	}

	if baseRuntimeAlert.SHA1Hash == "" && hostPath != "" {
		sha1hash, err := utils.CalculateSHA1FileHash(hostPath)
		if err != nil {
			sha1hash = ""
		}

		baseRuntimeAlert.SHA1Hash = sha1hash
	}

	if baseRuntimeAlert.SHA256Hash == "" && hostPath != "" {
		sha256hash, err := utils.CalculateSHA256FileHash(hostPath)
		if err != nil {
			sha256hash = ""
		}

		baseRuntimeAlert.SHA256Hash = sha256hash
	}

	if baseRuntimeAlert.Size == "" && hostPath != "" {
		size, err := utils.GetFileSize(hostPath)
		if err != nil {
			baseRuntimeAlert.Size = ""
		} else {
			baseRuntimeAlert.Size = humanize.Bytes(uint64(size))
		}
	}

	malwareResult.SetBasicRuntimeAlert(baseRuntimeAlert)

	runtimeProcessDetails := malwareResult.GetRuntimeProcessDetails()
	if runtimeProcessDetails.ProcessTree.Cmdline == "" {
		commandLine, err := utils.GetCmdlineByPid(int(malwareResult.GetRuntimeProcessDetails().ProcessTree.PID))
		if err != nil {
			runtimeProcessDetails.ProcessTree.Cmdline = ""
		} else {
			runtimeProcessDetails.ProcessTree.Cmdline = *commandLine
		}
	}

	if runtimeProcessDetails.ProcessTree.PPID == 0 {
		parent, err := utils.GetProcessStat(int(malwareResult.GetRuntimeProcessDetails().ProcessTree.PID))
		if err != nil {
			runtimeProcessDetails.ProcessTree.PPID = 0
		} else {
			runtimeProcessDetails.ProcessTree.PPID = uint32(parent.PPID)
		}

		if runtimeProcessDetails.ProcessTree.Pcomm == "" {
			if err == nil {
				runtimeProcessDetails.ProcessTree.Pcomm = parent.Comm
			} else {
				runtimeProcessDetails.ProcessTree.Pcomm = ""
			}
		}
	}

	if runtimeProcessDetails.ProcessTree.PID == 0 {
		runtimeProcessDetails.ProcessTree.PID = malwareResult.GetRuntimeProcessDetails().ProcessTree.PID
	}

	if runtimeProcessDetails.ProcessTree.Comm == "" {
		comm, err := utils.GetCommFromPid(malwareResult.GetRuntimeProcessDetails().ProcessTree.PID)
		if err != nil {
			comm = ""
		}
		runtimeProcessDetails.ProcessTree.Comm = comm
	}

	if runtimeProcessDetails.ProcessTree.Path == "" && path != "" {
		runtimeProcessDetails.ProcessTree.Path = path
	}

	if mm.containerIdToShimPid.Has(malwareResult.GetRuntimeProcessDetails().ContainerID) {
		shimPid := mm.containerIdToShimPid.Get(malwareResult.GetRuntimeProcessDetails().ContainerID)
		tree, err := utils.CreateProcessTree(&runtimeProcessDetails.ProcessTree, shimPid)
		if err == nil {
			runtimeProcessDetails.ProcessTree = *tree
		}
	}

	malwareResult.SetRuntimeProcessDetails(runtimeProcessDetails)

	// Enrich RuntimeAlertK8sDetails
	runtimek8sdetails := malwareResult.GetRuntimeAlertK8sDetails()
	if runtimek8sdetails.Image == "" {
		runtimek8sdetails.Image = malwareResult.GetTriggerEvent().Runtime.ContainerImageName
	}

	if runtimek8sdetails.ImageDigest == "" {
		runtimek8sdetails.ImageDigest = malwareResult.GetTriggerEvent().Runtime.ContainerImageDigest
	}

	if runtimek8sdetails.Namespace == "" {
		runtimek8sdetails.Namespace = malwareResult.GetTriggerEvent().K8s.Namespace
	}

	if runtimek8sdetails.PodName == "" {
		runtimek8sdetails.PodName = malwareResult.GetTriggerEvent().K8s.PodName
	}

	if runtimek8sdetails.PodNamespace == "" {
		runtimek8sdetails.PodNamespace = malwareResult.GetTriggerEvent().K8s.Namespace
	}

	if runtimek8sdetails.ContainerName == "" {
		runtimek8sdetails.ContainerName = malwareResult.GetTriggerEvent().Runtime.ContainerName
	}

	if runtimek8sdetails.ContainerID == "" {
		runtimek8sdetails.ContainerID = malwareResult.GetTriggerEvent().Runtime.ContainerID
	}

	if runtimek8sdetails.HostNetwork == nil {
		hostNetwork := malwareResult.GetTriggerEvent().K8s.HostNetwork
		runtimek8sdetails.HostNetwork = &hostNetwork
	}

	malwareResult.SetRuntimeAlertK8sDetails(runtimek8sdetails)

	return malwareResult
}
