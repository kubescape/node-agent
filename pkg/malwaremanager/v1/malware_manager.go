package malwaremanager

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/cenkalti/backoff/v5"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/dustin/go-humanize"
	"github.com/goradd/maps"
	containercollection "github.com/inspektor-gadget/inspektor-gadget/pkg/container-collection"
	tracerexectype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/exec/types"
	traceropentype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/open/types"
	"github.com/kubescape/go-logger"
	"github.com/kubescape/go-logger/helpers"
	"github.com/kubescape/node-agent/pkg/config"
	"github.com/kubescape/node-agent/pkg/ebpf/events"
	"github.com/kubescape/node-agent/pkg/exporters"
	"github.com/kubescape/node-agent/pkg/k8sclient"
	"github.com/kubescape/node-agent/pkg/malwaremanager"
	clamavv1 "github.com/kubescape/node-agent/pkg/malwaremanager/v1/clamav"
	"github.com/kubescape/node-agent/pkg/metricsmanager"
	"github.com/kubescape/node-agent/pkg/objectcache"
	"github.com/kubescape/node-agent/pkg/utils"
)

const (
	ScannedFilesMaxBufferLength = 10000
	maxFileSize                 = 50 * 1024 * 1024 // 50MB
)

type MalwareManager struct {
	scannedFiles         maps.SafeMap[string, mapset.Set[string]]
	containerIdToPid     maps.SafeMap[string, uint32]
	podToWlid            maps.SafeMap[string, string] // key is namespace/podName
	exporter             exporters.Exporter
	metrics              metricsmanager.MetricsManager
	k8sClient            k8sclient.K8sClientInterface
	nodeName             string
	clusterName          string
	malwareScanners      []malwaremanager.MalwareScanner
	cfg                  config.Config
	containerIdToShimPid maps.SafeMap[string, uint32]
	k8sObjectCache       objectcache.K8sObjectCache
}

var _ malwaremanager.MalwareManagerClient = (*MalwareManager)(nil)

func CreateMalwareManager(cfg config.Config, k8sClient k8sclient.K8sClientInterface, nodeName string, clusterName string, exporter exporters.Exporter, prometheusExporter metricsmanager.MetricsManager, k8sObjectCache objectcache.K8sObjectCache) (*MalwareManager, error) {

	// Create malware scanners
	var malwareScanners []malwaremanager.MalwareScanner

	// Create ClamAV scanner
	// Check if ClamAV is enabled (CLAMAV_SOCKET env var is set)
	if clamavSocket, present := os.LookupEnv("CLAMAV_SOCKET"); present {
		clamavScanner, err := clamavv1.CreateClamAVClient(clamavSocket)
		if err != nil {
			return nil, err
		}
		malwareScanners = append(malwareScanners, clamavScanner)
	}
	return &MalwareManager{
		cfg:             cfg,
		malwareScanners: malwareScanners,
		exporter:        exporter,
		k8sClient:       k8sClient,
		nodeName:        nodeName,
		clusterName:     clusterName,
		metrics:         prometheusExporter,
		k8sObjectCache:  k8sObjectCache,
	}, nil
}

func (mm *MalwareManager) ContainerCallback(notif containercollection.PubSubEvent) {
	// check if the container should be ignored
	if mm.cfg.SkipNamespace(notif.Container.K8s.Namespace) {
		return
	}

	t := time.NewTicker(utils.AddJitter(mm.cfg.InitialDelay, mm.cfg.MaxJitterPercentage))

	switch notif.Type {
	case containercollection.EventTypeAddContainer:
		mm.containerIdToPid.Set(notif.Container.Runtime.ContainerID, notif.Container.ContainerPid())
		shim, err := utils.GetProcessStat(int(notif.Container.ContainerPid()))
		if err != nil {
			logger.L().Warning("RuleManager - failed to get shim process", helpers.Error(err))
		} else {
			mm.containerIdToShimPid.Set(notif.Container.Runtime.ContainerID, uint32(shim.PPID))
		}
		go mm.startMalwareManager(notif.Container)
	case containercollection.EventTypeRemoveContainer:
		mm.containerIdToPid.Delete(notif.Container.Runtime.ContainerID)
		t.Stop()
		mm.scannedFiles.Delete(notif.Container.Runtime.ContainerID)
		mm.podToWlid.Delete(utils.CreateK8sPodID(notif.Container.K8s.Namespace, notif.Container.K8s.PodName))
		mm.containerIdToShimPid.Delete(notif.Container.Runtime.ContainerID)
	}

	go func() {
		for {
			select {
			case <-t.C:
				mm.scannedFiles.Set(notif.Container.Runtime.ContainerID, mapset.NewSet[string]())
				return
			}
		}
	}()
}

func (mm *MalwareManager) startMalwareManager(container *containercollection.Container) {
	// Wait for the shared container data to be available
	sharedData, err := mm.waitForSharedContainerData(container.Runtime.ContainerID)
	if err != nil {
		logger.L().Error("MalwareManager - failed to get shared container data", helpers.Error(err))
		return
	}
	podID := utils.CreateK8sPodID(container.K8s.Namespace, container.K8s.PodName)
	if !mm.podToWlid.Has(podID) {
		w := sharedData.Wlid
		if w != "" {
			mm.podToWlid.Set(podID, w)
		} else {
			logger.L().Debug("MalwareManager - failed to get workload identifier", helpers.String("k8s workload", container.K8s.PodName))
		}
	}
}

func (mm *MalwareManager) waitForSharedContainerData(containerID string) (*utils.WatchedContainerData, error) {
	return backoff.Retry(context.Background(), func() (*utils.WatchedContainerData, error) {
		if sharedData := mm.k8sObjectCache.GetSharedContainerData(containerID); sharedData != nil {
			return sharedData, nil
		}
		return nil, fmt.Errorf("container %s not found in shared data", containerID)
	}, backoff.WithBackOff(backoff.NewExponentialBackOff()))
}

func (mm *MalwareManager) ReportEvent(eventType utils.EventType, event utils.K8sEvent) {
	switch eventType {
	case utils.ExecveEventType:
		exec, ok := event.(*events.ExecEvent)
		if !ok {
			logger.L().Warning("MalwareManager - failed to cast event to execve event")
			return
		}
		mm.reportFileExec(&exec.Event)
	case utils.OpenEventType:
		open, ok := event.(*events.OpenEvent)
		if !ok {
			logger.L().Warning("MalwareManager - failed to cast event to open event")
			return
		}
		mm.reportFileOpen(&open.Event)
	}
}

func (mm *MalwareManager) reportFileExec(event *tracerexectype.Event) {
	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(utils.ExecveEventType, event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			result = mm.enrichMalwareResult(result)
			result.SetWorkloadDetails(mm.podToWlid.Get(utils.CreateK8sPodID(event.GetNamespace(), event.GetPod())))
			mm.exporter.SendMalwareAlert(result)
		}
	}

	if mm.scannedFiles.Has(event.Runtime.ContainerID) && mm.scannedFiles.Get(event.Runtime.ContainerID).Cardinality() <= ScannedFilesMaxBufferLength {
		hostFilePath, err := utils.GetHostFilePathFromEvent(event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
		if err != nil {
			return
		}

		mm.scannedFiles.Get(event.Runtime.ContainerID).Add(hostFilePath)
	}
}

func (mm *MalwareManager) reportFileOpen(event *traceropentype.Event) {
	// TODO: Add a check if the file is being opened for read.

	// Skip directories.
	if event.ModeRaw.IsDir() {
		return
	}

	hostFilePath, err := utils.GetHostFilePathFromEvent(event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
	if err != nil {
		return
	}

	if mm.scannedFiles.Has(event.Runtime.ContainerID) {
		// If the file has already been scanned, return.
		scannedFiles := mm.scannedFiles.Get(event.Runtime.ContainerID)
		if scannedFiles.Contains(hostFilePath) {
			return
		}

		// Add the scanned file to the cache.
		if scannedFiles.Cardinality() <= ScannedFilesMaxBufferLength {
			scannedFiles.Add(hostFilePath)
		}
	}

	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(utils.OpenEventType, event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			result = mm.enrichMalwareResult(result)
			result.SetWorkloadDetails(mm.podToWlid.Get(utils.CreateK8sPodID(event.GetNamespace(), event.GetPod())))
			mm.exporter.SendMalwareAlert(result)
			mm.metrics.ReportRuleAlert(result.GetBasicRuntimeAlert().AlertName)
		}
	}
}

func (mm *MalwareManager) enrichMalwareResult(malwareResult malwaremanager.MalwareResult) malwaremanager.MalwareResult {
	path, err := utils.GetPathFromPid(malwareResult.GetRuntimeProcessDetails().ProcessTree.PID)
	hostPath := ""
	if err != nil {
		path = ""
	} else {
		hostPath = filepath.Join("/proc", fmt.Sprintf("/%d/root/%s", malwareResult.GetRuntimeProcessDetails().ProcessTree.PID, path))
	}

	// Enrich BaseRuntimeAlert
	baseRuntimeAlert := malwareResult.GetBasicRuntimeAlert()

	baseRuntimeAlert.Timestamp = time.Unix(0, int64(malwareResult.GetTriggerEvent().Timestamp))

	var size int64 = 0
	if hostPath != "" {
		size, err = utils.GetFileSize(hostPath)
		if err != nil {
			size = 0
		}
	}

	if baseRuntimeAlert.Size == "" && hostPath != "" && size != 0 {
		baseRuntimeAlert.Size = humanize.Bytes(uint64(size))
	}

	if size != 0 && size < maxFileSize && hostPath != "" {
		if baseRuntimeAlert.MD5Hash == "" || baseRuntimeAlert.SHA1Hash == "" {
			sha1hash, md5hash, err := utils.CalculateFileHashes(hostPath)
			if err == nil {
				baseRuntimeAlert.MD5Hash = md5hash
				baseRuntimeAlert.SHA1Hash = sha1hash
			}
		}
	}

	malwareResult.SetBasicRuntimeAlert(baseRuntimeAlert)

	runtimeProcessDetails := malwareResult.GetRuntimeProcessDetails()
	if runtimeProcessDetails.ProcessTree.Cmdline == "" {
		commandLine, err := utils.GetCmdlineByPid(int(malwareResult.GetRuntimeProcessDetails().ProcessTree.PID))
		if err != nil {
			runtimeProcessDetails.ProcessTree.Cmdline = ""
		} else {
			runtimeProcessDetails.ProcessTree.Cmdline = *commandLine
		}
	}

	if runtimeProcessDetails.ProcessTree.PPID == 0 {
		parent, err := utils.GetProcessStat(int(malwareResult.GetRuntimeProcessDetails().ProcessTree.PID))
		if err != nil {
			runtimeProcessDetails.ProcessTree.PPID = 0
		} else {
			runtimeProcessDetails.ProcessTree.PPID = uint32(parent.PPID)
		}

		if runtimeProcessDetails.ProcessTree.Pcomm == "" {
			if err == nil {
				runtimeProcessDetails.ProcessTree.Pcomm = parent.Comm
			} else {
				runtimeProcessDetails.ProcessTree.Pcomm = ""
			}
		}
	}

	if runtimeProcessDetails.ProcessTree.PID == 0 {
		runtimeProcessDetails.ProcessTree.PID = malwareResult.GetRuntimeProcessDetails().ProcessTree.PID
	}

	if runtimeProcessDetails.ProcessTree.Comm == "" {
		comm, err := utils.GetCommFromPid(malwareResult.GetRuntimeProcessDetails().ProcessTree.PID)
		if err != nil {
			comm = ""
		}
		runtimeProcessDetails.ProcessTree.Comm = comm
	}

	if runtimeProcessDetails.ProcessTree.Path == "" && path != "" {
		runtimeProcessDetails.ProcessTree.Path = path
	}

	if mm.containerIdToShimPid.Has(malwareResult.GetRuntimeProcessDetails().ContainerID) {
		shimPid := mm.containerIdToShimPid.Get(malwareResult.GetRuntimeProcessDetails().ContainerID)
		tree, err := utils.CreateProcessTree(&runtimeProcessDetails.ProcessTree, shimPid)
		if err == nil {
			runtimeProcessDetails.ProcessTree = *tree
		}
	}

	malwareResult.SetRuntimeProcessDetails(runtimeProcessDetails)

	// Enrich RuntimeAlertK8sDetails
	runtimek8sdetails := malwareResult.GetRuntimeAlertK8sDetails()
	if runtimek8sdetails.Image == "" {
		runtimek8sdetails.Image = malwareResult.GetTriggerEvent().Runtime.ContainerImageName
	}

	if runtimek8sdetails.ImageDigest == "" {
		runtimek8sdetails.ImageDigest = malwareResult.GetTriggerEvent().Runtime.ContainerImageDigest
	}

	if runtimek8sdetails.Namespace == "" {
		runtimek8sdetails.Namespace = malwareResult.GetTriggerEvent().K8s.Namespace
	}

	if runtimek8sdetails.PodName == "" {
		runtimek8sdetails.PodName = malwareResult.GetTriggerEvent().K8s.PodName
	}

	if runtimek8sdetails.PodNamespace == "" {
		runtimek8sdetails.PodNamespace = malwareResult.GetTriggerEvent().K8s.Namespace
	}

	if runtimek8sdetails.ContainerName == "" {
		runtimek8sdetails.ContainerName = malwareResult.GetTriggerEvent().K8s.ContainerName
	}

	if runtimek8sdetails.ContainerID == "" {
		runtimek8sdetails.ContainerID = malwareResult.GetTriggerEvent().Runtime.ContainerID
	}

	if runtimek8sdetails.HostNetwork == nil {
		hostNetwork := malwareResult.GetTriggerEvent().K8s.HostNetwork
		runtimek8sdetails.HostNetwork = &hostNetwork
	}

	malwareResult.SetRuntimeAlertK8sDetails(runtimek8sdetails)

	return malwareResult
}
