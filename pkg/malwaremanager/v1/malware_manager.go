package malwaremanager

import (
	"fmt"
	"node-agent/pkg/config"
	"node-agent/pkg/exporters"
	"node-agent/pkg/k8sclient"
	"node-agent/pkg/malwaremanager"
	clamavv1 "node-agent/pkg/malwaremanager/v1/clamav"
	"node-agent/pkg/metricsmanager"
	"node-agent/pkg/utils"
	"os"
	"time"

	"github.com/armosec/utils-k8s-go/wlid"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/goradd/maps"
	containercollection "github.com/inspektor-gadget/inspektor-gadget/pkg/container-collection"
	tracerexectype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/exec/types"
	traceropentype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/open/types"
	"github.com/kubescape/go-logger"
	"github.com/kubescape/go-logger/helpers"
	"github.com/kubescape/k8s-interface/workloadinterface"
)

const ScannedFilesMaxBufferLength = 10000

type MalwareManager struct {
	scannedFiles     maps.SafeMap[string, mapset.Set[string]]
	containerIdToPid maps.SafeMap[string, uint32]
	podToWlid        maps.SafeMap[string, string]
	exporter         exporters.Exporter
	metrics          metricsmanager.MetricsManager
	k8sClient        k8sclient.K8sClientInterface
	nodeName         string
	clusterName      string
	malwareScanners  []malwaremanager.MalwareScanner
	cfg              config.Config
}

var _ malwaremanager.MalwareManagerClient = (*MalwareManager)(nil)

func CreateMalwareManager(cfg config.Config, k8sClient k8sclient.K8sClientInterface, nodeName string, clusterName string, exporter exporters.Exporter, prometheusExporter metricsmanager.MetricsManager) (*MalwareManager, error) {

	// Create malware scanners
	malwareScanners := []malwaremanager.MalwareScanner{}

	// Create ClamAV scanner
	// Check if ClamAV is enabled (CLAMAV_ADDRESS env var is set in the format <host>:<port>)
	if clamavAddress, present := os.LookupEnv("CLAMAV_ADDRESS"); present {
		clamavConfig := clamavv1.ClamAVConfig{
			Address: clamavAddress,
		}
		clamavScanner, err := clamavv1.CreateClamAVClient(&clamavConfig)
		if err != nil {
			return nil, err
		}
		malwareScanners = append(malwareScanners, clamavScanner)
	}
	return &MalwareManager{
		cfg:             cfg,
		malwareScanners: malwareScanners,
		exporter:        exporter,
		k8sClient:       k8sClient,
		nodeName:        nodeName,
		clusterName:     clusterName,
		metrics:         prometheusExporter,
	}, nil
}

func (mm *MalwareManager) ContainerCallback(notif containercollection.PubSubEvent) {
	t := time.NewTicker(mm.cfg.InitialDelay)

	switch notif.Type {
	case containercollection.EventTypeAddContainer:
		mm.containerIdToPid.Set(notif.Container.Runtime.ContainerID, notif.Container.Pid)
		if !mm.podToWlid.Has(notif.Container.K8s.PodName) {
			wlid, err := mm.getWorkloadIdentifier(notif.Container.K8s.Namespace, notif.Container.K8s.PodName)
			if err != nil {
				logger.L().Debug("MalwareManager - failed to get workload identifier", helpers.Error(err), helpers.String("k8s workload", notif.Container.K8s.PodName))
			} else {
				mm.podToWlid.Set(notif.Container.K8s.PodName, wlid)
			}
		}
	case containercollection.EventTypeRemoveContainer:
		mm.containerIdToPid.Delete(notif.Container.Runtime.ContainerID)
		t.Stop()
		mm.scannedFiles.Delete(notif.Container.Runtime.ContainerID)
		mm.podToWlid.Delete(notif.Container.K8s.PodName)
	}

	go func() {
		for {
			select {
			case <-t.C:
				mm.scannedFiles.Set(notif.Container.Runtime.ContainerID, mapset.NewSet[string]())
				return
			}
		}
	}()
}

func (mm *MalwareManager) getWorkloadIdentifier(podNamespace, podName string) (string, error) {
	wl, err := mm.k8sClient.GetWorkload(podNamespace, "Pod", podName)
	if err != nil {
		return "", fmt.Errorf("failed to get workload: %w", err)
	}
	pod := wl.(*workloadinterface.Workload)

	// find parentWlid
	kind, name, err := mm.k8sClient.CalculateWorkloadParentRecursive(pod)
	if err != nil {
		return "", fmt.Errorf("failed to calculate workload parent: %w", err)
	}
	parentWorkload, err := mm.k8sClient.GetWorkload(pod.GetNamespace(), kind, name)
	if err != nil {
		return "", fmt.Errorf("failed to get parent workload: %w", err)
	}
	w := parentWorkload.(*workloadinterface.Workload)
	generatedWlid := w.GenerateWlid(mm.clusterName)
	err = wlid.IsWlidValid(generatedWlid)
	if err != nil {
		return "", fmt.Errorf("failed to validate WLID: %w", err)
	}

	return generatedWlid, nil
}

func (mm *MalwareManager) ReportFileExec(_ string, event tracerexectype.Event) {
	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(utils.ExecveEventType, &event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			result.SetWorkloadDetails(mm.podToWlid.Get(event.GetPod()))
			mm.exporter.SendMalwareAlert(result)
		}
	}

	if mm.scannedFiles.Has(event.Runtime.ContainerID) && mm.scannedFiles.Get(event.Runtime.ContainerID).Cardinality() <= ScannedFilesMaxBufferLength {
		hostFilePath, err := utils.GetHostFilePathFromEvent(&event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
		if err != nil {
			return
		}

		mm.scannedFiles.Get(event.Runtime.ContainerID).Add(hostFilePath)
	}
}

func (mm *MalwareManager) ReportFileOpen(_ string, event traceropentype.Event) {
	// TODO: Add a check if the file is being opened for read.

	// Skip directories.
	if event.ModeRaw.IsDir() {
		return
	}

	hostFilePath, err := utils.GetHostFilePathFromEvent(&event, mm.containerIdToPid.Get(event.Runtime.ContainerID))
	if err != nil {
		return
	}

	if mm.scannedFiles.Has(event.Runtime.ContainerID) {
		// If the file has already been scanned, return.
		scannedFiles := mm.scannedFiles.Get(event.Runtime.ContainerID)
		if scannedFiles.Contains(hostFilePath) {
			return
		}

		// Add the scanned file to the cache.
		if scannedFiles.Cardinality() <= ScannedFilesMaxBufferLength {
			scannedFiles.Add(hostFilePath)
		}
	}

	for _, scanner := range mm.malwareScanners {
		if result := scanner.Scan(utils.OpenEventType, &event, mm.containerIdToPid.Get(event.Runtime.ContainerID)); result != nil {
			result.SetWorkloadDetails(mm.podToWlid.Get(event.GetPod()))
			mm.exporter.SendMalwareAlert(result)
			mm.metrics.ReportRuleAlert("malware") // @amit: add rule name
		}
	}
}
