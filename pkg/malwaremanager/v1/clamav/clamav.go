package malwaremanager

import (
	"node-agent/pkg/malwaremanager"
	mmtypes "node-agent/pkg/malwaremanager/v1/types"
	"node-agent/pkg/processtreemanager"
	nautils "node-agent/pkg/utils"
	"time"

	"github.com/cenkalti/backoff/v4"
	logger "github.com/kubescape/go-logger"
	"github.com/kubescape/go-logger/helpers"

	apitypes "github.com/armosec/armoapi-go/armotypes"
	humanize "github.com/dustin/go-humanize"
	"github.com/dutchcoders/go-clamd"
	tracerexectype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/exec/types"
	traceropentype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/open/types"
)

type ClamAVClient struct {
	clamd *clamd.Clamd
	cfg   *ClamAVConfig
	ptm   processtreemanager.ProcessTreeManagerClient
}

var _ malwaremanager.MalwareScanner = (*ClamAVClient)(nil)

const (
	FixSuggestions = "Please remove the file from the system. If the file is required, please contact your security team for further investigation."
)

func CreateClamAVClient(cfg *ClamAVConfig, ptm processtreemanager.ProcessTreeManagerClient) (*ClamAVClient, error) {
	clamdAddress, err := cfg.GetNormalizedAddress()
	if err != nil {
		return nil, err
	}

	clamd := clamd.NewClamd(clamdAddress)
	clamavClient := ClamAVClient{
		clamd: clamd,
		cfg:   cfg,
		ptm:   ptm,
	}

	// Ping ClamAV with backoff to ensure it is up and running.
	if err := backoff.Retry(func() error {
		return clamavClient.Ping()
	}, backoff.NewExponentialBackOff()); err != nil {
		logger.L().Error("Error pinging ClamAV", helpers.Error(err))
		return nil, err
	}

	return &clamavClient, nil
}

func (c *ClamAVClient) Scan(eventType nautils.EventType, event interface{}, containerPid uint32) malwaremanager.MalwareResult {
	// Check if the event is of type tracerexectype.Event or traceropentype.Event.
	if eventType != nautils.ExecveEventType && eventType != nautils.OpenEventType {
		return nil
	}

	if eventType == nautils.ExecveEventType {
		return c.handleExecEvent(event.(*tracerexectype.Event), containerPid)
	} else if eventType == nautils.OpenEventType {
		return c.handleOpenEvent(event.(*traceropentype.Event), containerPid)
	}

	return nil
}

func (c *ClamAVClient) handleExecEvent(execEvent *tracerexectype.Event, containerPid uint32) malwaremanager.MalwareResult {
	if execEvent == nil {
		return nil
	}

	hostFilePath, err := nautils.GetHostFilePathFromEvent(execEvent, containerPid)
	if err != nil {
		logger.L().Error("Error getting host file path", helpers.Error(err))
		return nil
	}

	response, err := c.clamd.ScanFile(hostFilePath)
	if err != nil {
		logger.L().Error("Error scanning file", helpers.Error(err))
		return nil
	}

	for result := range response {
		if result.Status == clamd.RES_FOUND {
			// A malware was found, send an alert.
			sha256hash, err := nautils.CalculateSHA256FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			sha1hash, err := nautils.CalculateSHA1FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			md5hash, err := nautils.CalculateMD5FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			size, err := nautils.GetFileSize(result.Path)
			if err != nil {
				logger.L().Error("Error getting file size of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			sizeStr := humanize.IBytes(uint64(size))
			process := c.ptm.GetProcessTreeByContainerId(execEvent.Runtime.ContainerID)
			processTracking := c.ptm.GetTreeTrackingByContainerId(execEvent.Runtime.ContainerID)
			return &mmtypes.GenericMalwareResult{
				BasicRuntimeAlert: apitypes.BaseRuntimeAlert{
					AlertName: result.Description,
					Arguments: map[string]interface{}{
						"hardlink": execEvent.ExePath,
					},
					FixSuggestions:      FixSuggestions,
					InfectedPID:         execEvent.Pid,
					ProcessTreeUniqueID: processTracking.UniqueID,
					SHA1Hash:            sha1hash,
					SHA256Hash:          sha256hash,
					MD5Hash:             md5hash,
					Severity:            10, // TODO: Get severity from api.
					Size:                &sizeStr,
					Timestamp:           time.Unix(int64(execEvent.Timestamp), 0),
				},
				RuntimeProcessDetails: apitypes.ProcessTree{
					ProcessTree: *process,
					UniqueID:    processTracking.UniqueID,
					ContainerID: execEvent.Runtime.ContainerID,
				},
				TriggerEvent: execEvent.Event,
				MalwareRuntimeAlert: apitypes.MalwareAlert{
					MalwareDescription: result.Description,
				},
				RuntimeAlertK8sDetails: apitypes.RuntimeAlertK8sDetails{
					ContainerID:   execEvent.Runtime.ContainerID,
					ContainerName: execEvent.Runtime.ContainerName,
					Namespace:     execEvent.GetNamespace(),
					PodName:       execEvent.GetPod(),
					PodNamespace:  execEvent.GetNamespace(),
					HostNetwork:   &execEvent.K8s.HostNetwork,
					Image:         execEvent.Runtime.ContainerImageName,
					ImageDigest:   execEvent.Runtime.ContainerImageDigest,
				},
			}
		}
	}

	return nil
}

func (c *ClamAVClient) handleOpenEvent(openEvent *traceropentype.Event, containerPid uint32) malwaremanager.MalwareResult {
	if openEvent == nil {
		return nil
	}

	hostFilePath, err := nautils.GetHostFilePathFromEvent(openEvent, containerPid)
	if err != nil {
		logger.L().Error("Error getting host file path", helpers.Error(err))
		return nil
	}

	response, err := c.clamd.ScanFile(hostFilePath)
	if err != nil {
		logger.L().Error("Error scanning file", helpers.Error(err))
		return nil
	}

	for result := range response {
		if result.Status == clamd.RES_FOUND {
			// A malware was found, send an alert.
			sha256hash, err := nautils.CalculateSHA256FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			sha1hash, err := nautils.CalculateSHA1FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			md5hash, err := nautils.CalculateMD5FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			size, err := nautils.GetFileSize(result.Path)
			if err != nil {
				logger.L().Error("Error getting file size of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			sizeStr := humanize.IBytes(uint64(size))
			process := c.ptm.GetProcessTreeByContainerId(openEvent.Runtime.ContainerID)
			processTracking := c.ptm.GetTreeTrackingByContainerId(openEvent.Runtime.ContainerID)
			return &mmtypes.GenericMalwareResult{
				BasicRuntimeAlert: apitypes.BaseRuntimeAlert{
					AlertName:           result.Description,
					InfectedPID:         openEvent.Pid,
					ProcessTreeUniqueID: processTracking.UniqueID,
					FixSuggestions:      FixSuggestions,
					SHA1Hash:            sha1hash,
					SHA256Hash:          sha256hash,
					MD5Hash:             md5hash,
					Severity:            10, // TODO: Get severity from api.
					Size:                &sizeStr,
					Timestamp:           time.Unix(int64(openEvent.Timestamp), 0),
				},
				RuntimeProcessDetails: apitypes.ProcessTree{
					ProcessTree: *process,
					UniqueID:    processTracking.UniqueID,
					ContainerID: openEvent.Runtime.ContainerID,
				},
				TriggerEvent: openEvent.Event,
				MalwareRuntimeAlert: apitypes.MalwareAlert{
					MalwareDescription: result.Description,
				},
				RuntimeAlertK8sDetails: apitypes.RuntimeAlertK8sDetails{
					ContainerID:   openEvent.Runtime.ContainerID,
					ContainerName: openEvent.Runtime.ContainerName,
					Namespace:     openEvent.GetNamespace(),
					PodName:       openEvent.GetPod(),
					PodNamespace:  openEvent.GetNamespace(),
					HostNetwork:   &openEvent.K8s.HostNetwork,
					Image:         openEvent.Runtime.ContainerImageName,
					ImageDigest:   openEvent.Runtime.ContainerImageDigest,
				},
			}
		}
	}

	return nil
}

// Ping ClamAV
func (c *ClamAVClient) Ping() error {
	return c.clamd.Ping()
}
