package malwaremanager

import (
	"fmt"
	"node-agent/pkg/malwaremanager"
	mmtypes "node-agent/pkg/malwaremanager/v1/types"
	nautils "node-agent/pkg/utils"
	"time"

	"os"
	"strings"

	"github.com/cenkalti/backoff/v4"
	logger "github.com/kubescape/go-logger"
	"github.com/kubescape/go-logger/helpers"

	apitypes "github.com/armosec/armoapi-go/armotypes"
	humanize "github.com/dustin/go-humanize"
	"github.com/dutchcoders/go-clamd"
	tracerexectype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/exec/types"
	traceropentype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/open/types"
)

type ClamAVClient struct {
	clamd *clamd.Clamd
	cfg   *ClamAVConfig
}

var _ malwaremanager.MalwareScanner = (*ClamAVClient)(nil)

const (
	FixSuggestions = "Please remove the file from the system. If the file is required, please contact your security team for further investigation."
)

func CreateClamAVClient(cfg *ClamAVConfig) (*ClamAVClient, error) {
	clamdAddress, err := cfg.GetNormalizedAddress()
	if err != nil {
		return nil, err
	}

	clamd := clamd.NewClamd(clamdAddress)
	clamavClient := ClamAVClient{
		clamd: clamd,
		cfg:   cfg,
	}

	// Ping ClamAV with backoff to ensure it is up and running.
	if err := backoff.Retry(func() error {
		return clamavClient.Ping()
	}, backoff.NewExponentialBackOff()); err != nil {
		logger.L().Error("Error pinging ClamAV", helpers.Error(err))
		return nil, err
	}

	return &clamavClient, nil
}

func (c *ClamAVClient) Scan(eventType nautils.EventType, event interface{}, containerPid uint32) malwaremanager.MalwareResult {
	// Check if the event is of type tracerexectype.Event or traceropentype.Event.
	if eventType != nautils.ExecveEventType && eventType != nautils.OpenEventType {
		return nil
	}

	if eventType == nautils.ExecveEventType {
		return c.handleExecEvent(event.(*tracerexectype.Event), containerPid)
	} else if eventType == nautils.OpenEventType {
		return c.handleOpenEvent(event.(*traceropentype.Event), containerPid)
	}

	return nil
}

func (c *ClamAVClient) handleExecEvent(execEvent *tracerexectype.Event, containerPid uint32) malwaremanager.MalwareResult {
	if execEvent == nil {
		return nil
	}

	hostFilePath, err := nautils.GetHostFilePathFromEvent(execEvent, containerPid)
	if err != nil {
		logger.L().Error("Error getting host file path", helpers.Error(err))
		return nil
	}

	response, err := c.clamd.ScanFile(hostFilePath)
	if err != nil {
		logger.L().Error("Error scanning file", helpers.Error(err))
		return nil
	}

	for result := range response {
		if result.Status == clamd.RES_FOUND {
			// A malware was found, send an alert.
			sha256hash, err := nautils.CalculateSHA256FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			sha1hash, err := nautils.CalculateSHA1FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			md5hash, err := nautils.CalculateMD5FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			size, err := nautils.GetFileSize(result.Path)
			if err != nil {
				logger.L().Error("Error getting file size of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			path := strings.TrimPrefix(result.Path, os.Getenv("HOST_ROOT"))
			commandLine := fmt.Sprintf("%s %s", execEvent.Comm, strings.Join(execEvent.Args, " "))
			isPartOfImage := !execEvent.UpperLayer
			sizeStr := humanize.IBytes(uint64(size))
			return &mmtypes.GenericMalwareResult{
				BasicRuntimeAlert: apitypes.BaseRuntimeAlert{
					AlertName: result.Description,
					Arguments: map[string]interface{}{
						"hardlink": execEvent.ExePath,
					},
					CommandLine:    &commandLine,
					FixSuggestions: FixSuggestions,
					IsPartOfImage:  &isPartOfImage,
					PPID:           &execEvent.Ppid,
					PPIDComm:       &execEvent.Pcomm,
					SHA1Hash:       sha1hash,
					SHA256Hash:     sha256hash,
					MD5Hash:        md5hash,
					Severity:       10, // TODO: Get severity from api.
					Size:           &sizeStr,
					Timestamp:      time.Unix(int64(execEvent.Timestamp), 0),
				},
				RuntimeProcessDetails: apitypes.RuntimeAlertProcessDetails{
					Comm: execEvent.Comm,
					GID:  execEvent.Gid,
					Path: path,
					PID:  execEvent.Pid,
					UID:  execEvent.Uid,
				},
				TriggerEvent: execEvent.Event,
				MalwareRuntimeAlert: apitypes.MalwareAlert{
					MalwareDescription: result.Description,
				},
				RuntimeAlertK8sDetails: apitypes.RuntimeAlertK8sDetails{
					ContainerID:   execEvent.Runtime.ContainerID,
					ContainerName: execEvent.Runtime.ContainerName,
					Namespace:     execEvent.GetNamespace(),
					PodName:       execEvent.GetPod(),
					PodNamespace:  execEvent.GetNamespace(),
					HostNetwork:   &execEvent.K8s.HostNetwork,
					Image:         execEvent.Runtime.ContainerImageName,
					ImageDigest:   execEvent.Runtime.ContainerImageDigest,
				},
			}
		}
	}

	return nil
}

func (c *ClamAVClient) handleOpenEvent(openEvent *traceropentype.Event, containerPid uint32) malwaremanager.MalwareResult {
	if openEvent == nil {
		return nil
	}

	hostFilePath, err := nautils.GetHostFilePathFromEvent(openEvent, containerPid)
	if err != nil {
		logger.L().Error("Error getting host file path", helpers.Error(err))
		return nil
	}

	response, err := c.clamd.ScanFile(hostFilePath)
	if err != nil {
		logger.L().Error("Error scanning file", helpers.Error(err))
		return nil
	}

	for result := range response {
		if result.Status == clamd.RES_FOUND {
			// A malware was found, send an alert.
			sha256hash, err := nautils.CalculateSHA256FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			sha1hash, err := nautils.CalculateSHA1FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			md5hash, err := nautils.CalculateMD5FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			size, err := nautils.GetFileSize(result.Path)
			if err != nil {
				logger.L().Error("Error getting file size of %s", helpers.String("path", result.Path), helpers.Error(err))
			}

			path := strings.TrimPrefix(result.Path, os.Getenv("HOST_ROOT"))

			cmdLine, err := nautils.GetCmdlineByPid(int(openEvent.Pid))
			if err != nil {
				logger.L().Error("Error getting command line of pid", helpers.Error(err))
				cmdLine = nil
			}

			var ppid *uint32
			var pcomm *string
			parent, err := nautils.GetParentByPid(int(openEvent.Pid))
			if err != nil {
				logger.L().Error("Error getting ppid of pid", helpers.Error(err))
				ppid = nil
				pcomm = nil
			} else {
				ppidValue := uint32(parent.PID)
				ppid = &ppidValue
				pcomm = &parent.Comm
			}
			sizeStr := humanize.IBytes(uint64(size))
			return &mmtypes.GenericMalwareResult{
				BasicRuntimeAlert: apitypes.BaseRuntimeAlert{
					AlertName:      result.Description,
					CommandLine:    cmdLine,
					FixSuggestions: FixSuggestions,
					IsPartOfImage:  nil, // We don't have that enrichement in the open event.
					PPID:           ppid,
					PPIDComm:       pcomm,
					SHA1Hash:       sha1hash,
					SHA256Hash:     sha256hash,
					MD5Hash:        md5hash,
					Severity:       10, // TODO: Get severity from api.
					Size:           &sizeStr,
					Timestamp:      time.Unix(int64(openEvent.Timestamp), 0),
				},
				RuntimeProcessDetails: apitypes.RuntimeAlertProcessDetails{
					Comm: openEvent.Comm,
					GID:  openEvent.Gid,
					Path: path,
					PID:  openEvent.Pid,
					UID:  openEvent.Uid,
				},
				TriggerEvent: openEvent.Event,
				MalwareRuntimeAlert: apitypes.MalwareAlert{
					MalwareDescription: result.Description,
				},
				RuntimeAlertK8sDetails: apitypes.RuntimeAlertK8sDetails{
					ContainerID:   openEvent.Runtime.ContainerID,
					ContainerName: openEvent.Runtime.ContainerName,
					Namespace:     openEvent.GetNamespace(),
					PodName:       openEvent.GetPod(),
					PodNamespace:  openEvent.GetNamespace(),
					HostNetwork:   &openEvent.K8s.HostNetwork,
					Image:         openEvent.Runtime.ContainerImageName,
					ImageDigest:   openEvent.Runtime.ContainerImageDigest,
				},
			}
		}
	}

	return nil
}

// Ping ClamAV
func (c *ClamAVClient) Ping() error {
	return c.clamd.Ping()
}
