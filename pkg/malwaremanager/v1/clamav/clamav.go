package malwaremanager

import (
	"node-agent/pkg/malwaremanager"
	nautils "node-agent/pkg/utils"

	"github.com/cenkalti/backoff/v4"
	"github.com/kubescape/go-logger"
	"github.com/kubescape/go-logger/helpers"

	"github.com/dutchcoders/go-clamd"
	tracerexectype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/exec/types"
	traceropentype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/open/types"
)

type ClamAVClient struct {
	clamd *clamd.Clamd
}

var _ malwaremanager.MalwareScanner = (*ClamAVClient)(nil)

const (
	FixSuggestions = "Please remove the file from the system. If the file is required, please contact your security team for further investigation."
)

func CreateClamAVClient(clamavSocket string) (*ClamAVClient, error) {
	c := clamd.NewClamd(clamavSocket)
	clamavClient := ClamAVClient{
		clamd: c,
	}

	// Ping ClamAV with backoff to ensure it is up and running.
	if err := backoff.Retry(func() error {
		return clamavClient.Ping()
	}, backoff.NewExponentialBackOff()); err != nil {
		logger.L().Error("Error pinging ClamAV", helpers.Error(err))
		return nil, err
	}

	return &clamavClient, nil
}

func (c *ClamAVClient) Scan(eventType nautils.EventType, event interface{}, containerPid uint32) malwaremanager.MalwareResult {
	// Check if the event is of type tracerexectype.Event or traceropentype.Event.
	switch eventType {
	case nautils.ExecveEventType:
		return c.handleExecEvent(event.(*tracerexectype.Event), containerPid)
	case nautils.OpenEventType:
		return c.handleOpenEvent(event.(*traceropentype.Event), containerPid)
	default:
		return nil
	}
}

// Ping ClamAV
func (c *ClamAVClient) Ping() error {
	return c.clamd.Ping()
}
