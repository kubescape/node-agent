package malwaremanager

import (
	"fmt"
	"node-agent/pkg/malwaremanager"
	mmtypes "node-agent/pkg/malwaremanager/v1/types"
	"node-agent/pkg/utils"
	nautils "node-agent/pkg/utils"
	"time"

	"os"
	"strings"

	"github.com/cenkalti/backoff/v4"
	"github.com/kubescape/go-logger"
	"github.com/kubescape/go-logger/helpers"

	apitypes "github.com/armosec/armoapi-go/armotypes"
	"github.com/dustin/go-humanize"
	"github.com/dutchcoders/go-clamd"
	tracerexectype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/exec/types"
	traceropentype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/open/types"
)

type ClamAVClient struct {
	clamd *clamd.Clamd
}

var _ malwaremanager.MalwareScanner = (*ClamAVClient)(nil)

const (
	FixSuggestions = "Please remove the file from the system. If the file is required, please contact your security team for further investigation."
)

func CreateClamAVClient(clamavSocket string) (*ClamAVClient, error) {
	c := clamd.NewClamd(clamavSocket)
	clamavClient := ClamAVClient{
		clamd: c,
	}

	// Ping ClamAV with backoff to ensure it is up and running.
	if err := backoff.Retry(func() error {
		return clamavClient.Ping()
	}, backoff.NewExponentialBackOff()); err != nil {
		logger.L().Error("Error pinging ClamAV", helpers.Error(err))
		return nil, err
	}

	return &clamavClient, nil
}

func (c *ClamAVClient) Scan(eventType nautils.EventType, event interface{}, containerPid uint32) malwaremanager.MalwareResult {
	// Check if the event is of type tracerexectype.Event or traceropentype.Event.
	switch eventType {
	case nautils.ExecveEventType:
		return c.handleExecEvent(event.(*tracerexectype.Event), containerPid)
	case nautils.OpenEventType:
		return c.handleOpenEvent(event.(*traceropentype.Event), containerPid)
	default:
		return nil
	}
}

func (c *ClamAVClient) handleExecEvent(execEvent *tracerexectype.Event, containerPid uint32) malwaremanager.MalwareResult {
	if execEvent == nil {
		return nil
	}

	hostFilePath, err := nautils.GetHostFilePathFromEvent(execEvent, containerPid)
	if err != nil {
		logger.L().Error("Error getting host file path", helpers.Error(err))
		return nil
	}

	response, err := c.clamd.ScanFile(hostFilePath)
	if err != nil {
		logger.L().Error("Error scanning file", helpers.Error(err))
		return nil
	}

	for result := range response {
		if result.Status == clamd.RES_FOUND {
			// A malware was found, send an alert.
			sha256hash, err := nautils.CalculateSHA256FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			sha1hash, err := nautils.CalculateSHA1FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			md5hash, err := nautils.CalculateMD5FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			size, err := nautils.GetFileSize(result.Path)
			if err != nil {
				logger.L().Error("Error getting file size of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			path := strings.TrimPrefix(result.Path, os.Getenv("HOST_ROOT"))

			commandLine := fmt.Sprintf("%s %s", utils.GetExecPathFromEvent(execEvent), utils.GetExecArgsFromEvent(execEvent))
			return &mmtypes.GenericMalwareResult{
				BasicRuntimeAlert: apitypes.BaseRuntimeAlert{
					AlertName:      result.Description,
					InfectedPID:    execEvent.Pid,
					FixSuggestions: FixSuggestions,
					SHA1Hash:       sha1hash,
					SHA256Hash:     sha256hash,
					MD5Hash:        md5hash,
					Severity:       10, // TODO: Get severity from api.
					Size:           humanize.IBytes(uint64(size)),
					Timestamp:      time.Unix(int64(execEvent.Timestamp), 0),
				},
				RuntimeProcessDetails: apitypes.ProcessTree{
					ProcessTree: apitypes.Process{
						Comm:       execEvent.Comm,
						Path:       path,
						Gid:        &execEvent.Gid,
						PID:        execEvent.Pid,
						Uid:        &execEvent.Uid,
						UpperLayer: execEvent.UpperLayer,
						PPID:       execEvent.Ppid,
						Pcomm:      execEvent.Pcomm,
						Cwd:        execEvent.Cwd,
						Hardlink:   execEvent.ExePath,
						Cmdline:    commandLine,
					},
					ContainerID: execEvent.Runtime.ContainerID,
				},
				TriggerEvent: execEvent.Event,
				MalwareRuntimeAlert: apitypes.MalwareAlert{
					MalwareDescription: result.Description,
				},
				RuntimeAlertK8sDetails: apitypes.RuntimeAlertK8sDetails{
					ContainerID:   execEvent.Runtime.ContainerID,
					ContainerName: execEvent.K8s.ContainerName,
					Namespace:     execEvent.GetNamespace(),
					PodName:       execEvent.GetPod(),
					PodNamespace:  execEvent.GetNamespace(),
					HostNetwork:   &execEvent.K8s.HostNetwork,
					Image:         execEvent.Runtime.ContainerImageName,
					ImageDigest:   execEvent.Runtime.ContainerImageDigest,
				},
			}
		}
	}

	return nil
}

func (c *ClamAVClient) handleOpenEvent(openEvent *traceropentype.Event, containerPid uint32) malwaremanager.MalwareResult {
	if openEvent == nil {
		return nil
	}

	hostFilePath, err := nautils.GetHostFilePathFromEvent(openEvent, containerPid)
	if err != nil {
		logger.L().Error("Error getting host file path", helpers.Error(err))
		return nil
	}

	response, err := c.clamd.ScanFile(hostFilePath)
	if err != nil {
		logger.L().Error("Error scanning file", helpers.Error(err))
		return nil
	}

	for result := range response {
		if result.Status == clamd.RES_FOUND {
			// A malware was found, send an alert.
			sha256hash, err := nautils.CalculateSHA256FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			sha1hash, err := nautils.CalculateSHA1FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			md5hash, err := nautils.CalculateMD5FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s", helpers.String("path", result.Path), helpers.Error(err))
			}
			size, err := nautils.GetFileSize(result.Path)
			if err != nil {
				logger.L().Error("Error getting file size of %s", helpers.String("path", result.Path), helpers.Error(err))
			}

			path := strings.TrimPrefix(result.Path, os.Getenv("HOST_ROOT"))
			return &mmtypes.GenericMalwareResult{
				BasicRuntimeAlert: apitypes.BaseRuntimeAlert{
					AlertName:      result.Description,
					InfectedPID:    openEvent.Pid,
					FixSuggestions: FixSuggestions,
					SHA1Hash:       sha1hash,
					SHA256Hash:     sha256hash,
					MD5Hash:        md5hash,
					Severity:       10, // TODO: Get severity from api.
					Size:           humanize.IBytes(uint64(size)),
					Timestamp:      time.Unix(int64(openEvent.Timestamp), 0),
				},
				RuntimeProcessDetails: apitypes.ProcessTree{
					ProcessTree: apitypes.Process{
						Comm: openEvent.Comm,
						Path: path,
						Gid:  &openEvent.Gid,
						PID:  openEvent.Pid,
						Uid:  &openEvent.Uid,
					},
					ContainerID: openEvent.Runtime.ContainerID,
				},
				TriggerEvent: openEvent.Event,
				MalwareRuntimeAlert: apitypes.MalwareAlert{
					MalwareDescription: result.Description,
				},
				RuntimeAlertK8sDetails: apitypes.RuntimeAlertK8sDetails{
					ContainerID:   openEvent.Runtime.ContainerID,
					ContainerName: openEvent.K8s.ContainerName,
					Namespace:     openEvent.GetNamespace(),
					PodName:       openEvent.GetPod(),
					PodNamespace:  openEvent.GetNamespace(),
					HostNetwork:   &openEvent.K8s.HostNetwork,
					Image:         openEvent.Runtime.ContainerImageName,
					ImageDigest:   openEvent.Runtime.ContainerImageDigest,
				},
			}
		}
	}

	return nil
}

// Ping ClamAV
func (c *ClamAVClient) Ping() error {
	return c.clamd.Ping()
}
