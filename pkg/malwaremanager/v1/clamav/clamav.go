package malwaremanager

import (
	"node-agent/pkg/malwaremanager"
	utils "node-agent/pkg/malwaremanager/utils"
	mmtypes "node-agent/pkg/malwaremanager/v1/types"

	"os"
	"strings"

	"github.com/cenkalti/backoff/v4"
	logger "github.com/kubescape/go-logger"
	"github.com/kubescape/go-logger/helpers"

	humanize "github.com/dustin/go-humanize"
	"github.com/dutchcoders/go-clamd"
	tracerexectype "github.com/inspektor-gadget/inspektor-gadget/pkg/gadgets/trace/exec/types"
)

type ClamAVClient struct {
	clamd *clamd.Clamd
	cfg   *ClamAVConfig
}

var _ malwaremanager.MalwareScanner = (*ClamAVClient)(nil)

func CreateClamAVClient(cfg *ClamAVConfig) (*ClamAVClient, error) {
	clamdAddress, err := cfg.GetNormalizedAddress()
	if err != nil {
		return nil, err
	}

	clamd := clamd.NewClamd(clamdAddress)
	clamavClient := ClamAVClient{
		clamd: clamd,
		cfg:   cfg,
	}

	// Ping ClamAV with backoff to ensure it is up and running.
	if err := backoff.Retry(func() error {
		return clamavClient.Ping()
	}, backoff.NewExponentialBackOff()); err != nil {
		logger.L().Error("Error pinging ClamAV: %v\n", helpers.String("error", err.Error()))
		return nil, err
	}

	return &clamavClient, nil
}

func (c *ClamAVClient) Scan(event interface{}) malwaremanager.MalwareResult {
	// Check if the event is of type tracerexectype.Event
	execEvent, ok := event.(*tracerexectype.Event)
	if !ok {
		return nil
	}

	// Scan the file
	response, err := c.clamd.ScanFile(utils.GetExecPathFromEvent(execEvent))
	if err != nil {
		logger.L().Error("Error scanning file: %v\n", helpers.String("error", err.Error()))
		return nil
	}

	for result := range response {
		if result.Status == clamd.RES_FOUND {
			// A malware was found, send an alert.
			sha256hash, err := utils.CalculateSHA256FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s: %v\n", helpers.String("path", result.Path), helpers.String("error", err.Error()))
			}
			sha1hash, err := utils.CalculateSHA1FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s: %v\n", helpers.String("path", result.Path), helpers.String("error", err.Error()))
			}
			md5hash, err := utils.CalculateMD5FileHash(result.Path)
			if err != nil {
				logger.L().Error("Error calculating hash of %s: %v\n", helpers.String("path", result.Path), helpers.String("error", err.Error()))
			}
			size, err := utils.GetFileSize(result.Path)
			if err != nil {
				logger.L().Error("Error getting file size of %s: %v\n", helpers.String("path", result.Path), helpers.String("error", err.Error()))
			}
			path := strings.TrimPrefix(result.Path, os.Getenv("HOST_ROOT"))
			return &mmtypes.GenericMalwareResult{
				Name:                 result.Description,
				Description:          result.Description,
				Path:                 path,
				SHA256Hash:           sha256hash,
				SHA1Hash:             sha1hash,
				MD5Hash:              md5hash,
				Size:                 humanize.IBytes(uint64(size)),
				IsPartOfImage:        execEvent.UpperLayer,
				Namespace:            execEvent.GetNamespace(),
				PodName:              execEvent.GetPod(),
				ContainerName:        execEvent.GetContainer(),
				ContainerID:          execEvent.Runtime.ContainerID,
				ContainerImage:       execEvent.GetContainerImageName(),
				ContainerImageDigest: execEvent.Runtime.ContainerImageDigest,
			}
		}
	}

	return nil
}

// Ping ClamAV
func (c *ClamAVClient) Ping() error {
	return c.clamd.Ping()
}
